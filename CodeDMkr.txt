#include <WiFi101.h>
#include <PubSubClient.h>
#include <Servo.h>
#include <DHT.h>

// âš¡ ParamÃ¨tres WiFi et MQTT
const char* ssid = "Samsung";         // Nom du WiFi
const char* password = "H120005065."; // Mot de passe WiFi
const char* mqtt_server = "192.168.53.94";  // IP du broker MQTT
const char* mqtt_topic = "home/mkr/sensors"; // Topic MQTT pour les capteurs

WiFiClient espClient;
PubSubClient client(espClient);

// âš¡ DÃ©finition des broches
const int FAN_PIN = 5;
const int LED_PIN = 4;
const int SERVO_PIN = 9;
#define DHTPIN 6
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

Servo servo;

// âš¡ Variables de gestion du temps
unsigned long lastDHTTime = 0;    // DerniÃ¨re fois oÃ¹ les donnÃ©es ont Ã©tÃ© envoyÃ©es
unsigned long interval = 60000;    // Intervalle de 60 secondes pour l'envoi des donnÃ©es

void setup() {
    Serial.begin(115200);
    delay(1000);

    // ðŸ”„ Connexion WiFi
    Serial.print("ðŸ”„ Connexion au WiFi ");
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(1000);
        Serial.print(".");
    }
    Serial.println("\nâœ… ConnectÃ© au WiFi !");
    Serial.print("ðŸ“¡ Adresse IP : ");
    Serial.println(WiFi.localIP());

    // ðŸ”„ Configuration MQTT
    client.setServer(mqtt_server, 1883);
    client.setCallback(callback);
    reconnectMQTT();

    // ðŸ”„ Initialisation du DHT11
    dht.begin();
    delay(2000);  // Laisser le capteur se stabiliser

    // ðŸ”„ Configuration des broches
    pinMode(FAN_PIN, OUTPUT);
    pinMode(LED_PIN, OUTPUT);
    servo.attach(SERVO_PIN);
}

// ðŸ“Œ Callback pour gÃ©rer les messages MQTT
void callback(char* topic, byte* payload, unsigned int length) {
    String msg = "";
    for (int i = 0; i < length; i++) {
        msg += (char)payload[i];
    }

    Serial.print("ðŸ“© Message reÃ§u sur [");
    Serial.print(topic);
    Serial.print("] : ");
    Serial.println(msg);

    // ContrÃ´le des pÃ©riphÃ©riques
    if (String(topic) == "fan/control") {
        digitalWrite(FAN_PIN, msg == "ON" ? HIGH : LOW);
        Serial.println(msg == "ON" ? "ðŸŒ¬ï¸ Ventilateur ALLUMÃ‰" : "ðŸ›‘ Ventilateur Ã‰TEINT");
    } 
    else if (String(topic) == "led/control") {
        digitalWrite(LED_PIN, msg == "ON" ? HIGH : LOW);
        Serial.println(msg == "ON" ? "ðŸ’¡ LED ALLUMÃ‰E" : "ðŸŒ‘ LED Ã‰TEINTE");
    } 
    else if (String(topic) == "servo/angle") {
        int angle = msg.toInt();
        servo.write(angle);
        Serial.print("ðŸ”„ Servo positionnÃ© Ã  ");
        Serial.print(angle);
        Serial.println("Â°");
    }
}

// ðŸ“Œ Fonction pour envoyer les donnÃ©es du DHT11 via MQTT
void sendSensorData() {
    float humidity = dht.readHumidity();
    float temperature = dht.readTemperature();
  
    if (!isnan(humidity) && !isnan(temperature)) {
        if (client.connected()) {
            String payload = "{\"temperature\": " + String(temperature) + ", \"humidity\": " + String(humidity) + "}";
            client.publish(mqtt_topic, payload.c_str());
            Serial.println("ðŸ“¡ DonnÃ©es envoyÃ©es : " + payload);
        } else {
            Serial.println("âš ï¸ Impossible d'envoyer les donnÃ©es, MQTT dÃ©connectÃ© !");
        }
    } else {
        Serial.println("âŒ Erreur de lecture du DHT11 !");
    }
}

// ðŸ“Œ Reconnexion au broker MQTT
void reconnectMQTT() {
    while (!client.connected()) {
        Serial.println("ðŸ”„ Connexion au broker MQTT...");
        if (client.connect("ArduinoMKR1000")) {
            Serial.println("âœ… ConnectÃ© au broker MQTT !");
            client.subscribe("fan/control");
            client.subscribe("led/control");
            client.subscribe("servo/angle");
        } else {
            Serial.print("âŒ Ã‰chec MQTT, erreur: ");
            Serial.println(client.state());
            Serial.println("â³ Nouvelle tentative dans 5s...");
            delay(5000);
        }
    }
}

void loop() {
    if (!client.connected()) {
        reconnectMQTT();
    }
    client.loop();

    unsigned long currentMillis = millis();
  
    // VÃ©rifier si 60 secondes sont passÃ©es
    if (currentMillis - lastDHTTime >= interval) {
        lastDHTTime = currentMillis;  // Sauvegarder le temps actuel
        sendSensorData();  // Envoyer les donnÃ©es du DHT11
    }
}
